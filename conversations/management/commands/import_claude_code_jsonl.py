#!/usr/bin/env python3
"""
Django management command to import single Claude Code JSONL file.

Usage:
    python manage.py import_claude_code_jsonl --file 097637c9-33b2-4806-bdcf-01540304de61.jsonl --era-id <uuid>
"""

import json
import uuid as uuid_lib
import re
from pathlib import Path
from datetime import datetime
from django.core.management.base import BaseCommand
from django.utils.dateparse import parse_datetime
from django.utils import timezone
from conversations.models import (
    Era, ContextHeap, ContextHeapType,
    Message, Thought, ToolUse, ToolResult, ThinkingEntity,
    CompactingAction
)
from conversations.utils.retry_detection import RetryDetector


def parse_command_xml(text):
    """Parse XML command patterns into structured data."""
    # Check for meta caveat
    if 'Caveat:' in text and 'generated by the user while running local commands' in text:
        return {
            'type': 'meta_caveat',
            'is_meta': True,
            'text': text
        }

    # Check for command invocation
    command_name_match = re.search(r'<command-name>(.+?)</command-name>', text)
    if command_name_match:
        command_message_match = re.search(r'<command-message>(.+?)</command-message>', text)
        command_args_match = re.search(r'<command-args>(.*?)</command-args>', text, re.DOTALL)

        return {
            'type': 'slash_command',
            'command_name': command_name_match.group(1),
            'command_message': command_message_match.group(1) if command_message_match else '',
            'command_args': command_args_match.group(1).strip() if command_args_match else '',
            'raw_xml': text
        }

    # Check for command output
    stdout_match = re.search(r'<local-command-stdout>(.*?)</local-command-stdout>', text, re.DOTALL)
    if stdout_match:
        return {
            'type': 'command_output',
            'stdout': stdout_match.group(1),
            'raw_xml': text
        }

    # Not a recognized pattern, return as plain text
    return text


class Command(BaseCommand):
    help = 'Import single Claude Code JSONL conversation file'

    def handle_summary(self, event, era, filename):
        """
        Handle all summaries in the file - whether messages exist or not.

        For each summary:
        1. Try to find the leaf message (compact boundary)
        2. If found, get its heap and look for continuation messages
        3. If not found, try to find the preceding message (message before the leaf)
        4. Create/update CompactingAction with links to heap and continuation

        Args:
            summary_data_by_leaf: Dict mapping leaf UUIDs to summary info
                Each value is a dict with:
                - 'summary_data': the actual summary object from JSONL
                - 'preceding_message_uuid': UUID of message before this summary (or None)
            messages: List of message dicts from JSONL
            era: Era to import into
            justin, magent: ThinkingEntity objects
            filename: Source filename

        Returns:
            tuple: (found_list, created_list) - lists of CompactingAction objects found vs created
        """
        leaf_uuid = uuid_lib.UUID(event['leafUuid'])
        summary_text = event['summary']

        # Try to find the leaf message in the database
        try:
            leaf_msg = Message.objects.get(id=leaf_uuid)
            heap = leaf_msg.context_heap

            self.stdout.write(self.style.SUCCESS(
                f'Found leaf message {str(leaf_uuid)[:8]} in heap {str(heap.id)[:8]}'
            ))

            # Create or update CompactingAction
            # Link to the continuation heap (where the compact leads TO), not the leaf's heap
            compacting_action, created = CompactingAction.from_jsonl_claude_code_v2(
                event,
                ending_message=leaf_msg,
            )

        except Message.DoesNotExist:
            # Leaf message doesn't exist yet - try to find preceding message
            preceding_msg = None
            if preceding_message_uuid_str:
                try:
                    preceding_uuid = uuid_lib.UUID(preceding_message_uuid_str)
                    preceding_msg = Message.objects.get(id=preceding_uuid)
                    self.stdout.write(self.style.SUCCESS(
                        f'Leaf {str(leaf_uuid)[:8]} not found, but found preceding message {str(preceding_uuid)[:8]}'
                    ))
                except Message.DoesNotExist:
                    self.stdout.write(self.style.WARNING(
                        f'Leaf {str(leaf_uuid)[:8]} AND preceding message {str(preceding_uuid)[:8]} not found'
                    ))

            self.stdout.write(self.style.WARNING(
                f'Creating orphaned CompactingAction for leaf {str(leaf_uuid)[:8]}'
            ))

            compact, created = CompactingAction.from_jsonl_claude_code_v2(
                summary_data,
                context_heap=None,
                ending_message_id=leaf_uuid,
                preceding_message=preceding_msg  # Will be None if not found
            )

            if created:
                created_list.append(compact)
                if preceding_msg:
                    self.stdout.write(self.style.WARNING(
                        f'Created orphaned CompactingAction {str(compact.id)[:8]} with preceding message {str(preceding_msg.id)[:8]}'
                    ))
                else:
                    self.stdout.write(self.style.WARNING(
                        f'Created orphaned CompactingAction {str(compact.id)[:8]} (no preceding message found)'
                    ))
            else:
                found_list.append(compact)
                self.stdout.write(self.style.WARNING(
                    f'Orphaned CompactingAction {str(compact.id)[:8]} already exists'
                ))

        return compacting_action, created

    def add_arguments(self, parser):
        parser.add_argument(
            '--file',
            type=str,
            required=True,
            help='JSONL file to import',
        )
        parser.add_argument(
            '--era-id',
            type=str,
            required=True,
            help='UUID of the Era to import into',
        )
    
    def import_line_from_claude_code_v2(self, line, era, filename):

        # Get entities
        # TODO: #12
        justin = ThinkingEntity.objects.get(name='justin')
        magent = ThinkingEntity.objects.get(name='magent')

        event_type, event = Message.detect_event_type_claude_code_v2(line)

        if event_type == "summary":
                compacting_action, created = self.handle_summary(event, era, filename)

                # We're likely reached the end of this heap.  TODO: Have we?  Let's handle it.
                return compacting_action, created
        
        # Get UUID
        msg_uuid = uuid_lib.UUID(event['uuid'])

        # Create appropriate message type based on event_type
        if event_type == "thought":
            sender = magent  # TODO: #12
            content = event['message']['content']
            signature = content[0]['signature']
            message, created = Thought.objects.get_or_create(
                id=msg_uuid,
                defaults={
                    'sender': sender,
                    'source_file': filename,
                    'content': content,
                    'signature': signature,
                    'created_at': timezone.now(),
                }
            )
        elif event_type == "tool use":
            if event['type'] == "assistant" and event['userType'] == "external":
                sender = magent
            else:
                assert False
            message, created = ToolUse.objects.get_or_create(
                id=msg_uuid,
                defaults={
                    'sender': sender,
                    'source_file': filename,
                    'tool_name': event.get('name', ''),
                    'tool_id': event.get('id', ''),
                    'content': event.get('input', {}),
                    'created_at': timezone.now(),
                }
            )
        elif event_type == "tool result":
            # TODO: #12
            if event['type'] == "user" and event['userType'] == "external":
                # TODO: This one is particularly strange - this result is coming _from_ the tool, not from a thinking entity at all.
                sender = magent
            else:
                assert False
            message, created = ToolResult.objects.get_or_create(
                id=msg_uuid,
                defaults={
                    'sender': sender,
                    'source_file': filename,
                    'content': event.get('content', ''),
                    'is_error': event.get('is_error', False),
                    'tool_use_id': event.get('tool_use_id', ''),
                    'created_at': timezone.now(),
                }
            )
        elif event_type == "continuation":
            # sender and recipient are both magent, like a thought.
            message, created = Message.objects.get_or_create(
                id=msg_uuid,
                defaults={
                    'sender': magent,
                    'source_file': filename,
                    'content': event['message']['content'],
                    'is_continuation_message': True,
                    'created_at': timezone.now(),
                }
            )
        elif event_type == "regular message":
            role = event['message']['role']
            content = event['message']['content']

            #### This block is clearly broken - we need real logic for this.
            if role == 'user':
                sender = justin
            elif role == 'assistant':
                sender = magent
            else:
                assert False

            message, created = Message.objects.get_or_create(
                id=msg_uuid,
                defaults={
                    'sender': sender,
                    'source_file': filename,
                    'content': content,
                    'created_at': timezone.now(),
                }
            )
        elif event_type == "uncertain message":
            # TODO: #12
            role = event['message']['role']
            content = event['message']['content']
            if role == "user":
                sender = justin
            else:
                assert False # Not sure what this can be?
            
            # TODO: Gracefully handle these situations (which probably arise from client errors or network problems)
            message, created = Message.objects.get_or_create(
                id=msg_uuid,
                defaults={
                    'sender': sender,
                    'source_file': filename,
                    'content': content,
                    'created_at': timezone.now(),
                }
            )
        elif event_type == "caveat":
            message, created = Message.objects.get_or_create(
                id=msg_uuid,
                defaults={
                    'sender': magent,
                    'source_file': filename,
                    'content': event.get('content', ''),
                    'is_continuation_message': (event_type == "continuation"),
                    'created_at': timezone.now(),
                }
            )
            message.recipients.add(magent)
        elif event_type in ("command", "command result - success"):
            # Parse command XML from event content
            text_content = event.get('message', {}).get('content', [{}])[0].get('text', '')
            parsed_content = parse_command_xml(text_content)

            message, created = Message.objects.get_or_create(
                id=msg_uuid,
                defaults={
                    'sender': magent,  # Command metadata is from system
                    'source_file': filename,
                    'content': parsed_content,
                }
            )

        else:
            assert False
            self.stdout.write(self.style.WARNING(f'Unknown event type: {event_type}'))
        return message, created


    def handle(self, *args, **options):
        filepath = Path(options['file'])
        era_id = options['era_id']

        if not filepath.exists():
            self.stdout.write(self.style.ERROR(f'File not found: {filepath}'))
            return

        # Get era
        try:
            era = Era.objects.get(id=era_id)
        except Era.DoesNotExist:
            self.stdout.write(self.style.ERROR(f'Era not found: {era_id}'))
            return

        # Get entities
        justin = ThinkingEntity.objects.get(name='justin')
        magent = ThinkingEntity.objects.get(name='magent')

        # Parse JSONL
        self.stdout.write(f'Parsing {filepath.name}...')
        events = []
        summary_data_by_leaf = {}
        previous_event = None
        filename = filepath.name
        last_known_compacting_action = None

        with open(filepath) as f:
            for line in f:
                event, created = self.import_line_from_claude_code_v2(line, era, filename)

                ##### Heap, summary, and continuation (ie, collection-level) handling 
                if event.__class__ == CompactingAction:
                    last_compact, last_compact_created = event, created

                if event.__class__ == Message and event.is_continuation_message:
                    if last_compact.continuation_message:
                        if last_compact.continuation_message == event:
                            # The continuation message is already set to this one.  We're fine.
                            pass
                        else:
                            raise RuntimeError("We already have a continuation for this compacting action.")
                    else:
                        last_compact.continuation_message = message
